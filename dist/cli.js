"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.options = void 0;

var _commander = require("commander");

var _package = _interopRequireDefault(require("../package.json"));

var _fs = _interopRequireDefault(require("fs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function parseShift(value) {
  var result = parseInt(value, 10);

  if (isNaN(result)) {
    console.error("'shift' argument value must an integer, received: ".concat(value));
    process.exit(1);
  }

  return result;
}

function parseAction(value) {
  if (value !== 'encode' && value !== 'decode') {
    console.error("'action' argument value must be 'encode'  'decode', received: ".concat(value));
    process.exit(1);
  }

  return value;
}

function parseInput(value) {
  if (value && !_fs["default"].existsSync(value)) {
    console.error("'input' argument value must be a valid path to file, received: ".concat(value));
    process.exit(1);
  }

  return value;
}

function parseOutput(value) {
  if (value && !_fs["default"].existsSync(value)) {
    console.error("'output' argument value must be a valid path to file, received: ".concat(value));
    process.exit(1);
  }

  return value;
}

var cli = new _commander.Command().version(_package["default"].version).requiredOption('-s, --shift <value>', 'a shift, number, required', parseShift).requiredOption('-a, --action <type>', 'an action, possible values: encode/decode, required', parseAction).option('-i, --input <path>', 'path to input file, options', parseInput).option('-o, --output <path>', 'path to output file, optional', parseOutput).parse(process.argv);
var options = cli.opts();
exports.options = options;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGkudHMiXSwibmFtZXMiOlsicGFyc2VTaGlmdCIsInZhbHVlIiwicmVzdWx0IiwicGFyc2VJbnQiLCJpc05hTiIsImNvbnNvbGUiLCJlcnJvciIsInByb2Nlc3MiLCJleGl0IiwicGFyc2VBY3Rpb24iLCJwYXJzZUlucHV0IiwiZnMiLCJleGlzdHNTeW5jIiwicGFyc2VPdXRwdXQiLCJjbGkiLCJDb21tYW5kIiwidmVyc2lvbiIsInBrZyIsInJlcXVpcmVkT3B0aW9uIiwib3B0aW9uIiwicGFyc2UiLCJhcmd2Iiwib3B0aW9ucyIsIm9wdHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7OztBQUVBLFNBQVNBLFVBQVQsQ0FBb0JDLEtBQXBCLEVBQW1DO0FBQ2pDLE1BQU1DLE1BQU0sR0FBR0MsUUFBUSxDQUFDRixLQUFELEVBQVEsRUFBUixDQUF2Qjs7QUFDQSxNQUFJRyxLQUFLLENBQUNGLE1BQUQsQ0FBVCxFQUFtQjtBQUNqQkcsSUFBQUEsT0FBTyxDQUFDQyxLQUFSLDZEQUFtRUwsS0FBbkU7QUFDQU0sSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsQ0FBYjtBQUNEOztBQUNELFNBQU9OLE1BQVA7QUFDRDs7QUFFRCxTQUFTTyxXQUFULENBQXFCUixLQUFyQixFQUFvQztBQUNsQyxNQUFJQSxLQUFLLEtBQUssUUFBVixJQUFzQkEsS0FBSyxLQUFLLFFBQXBDLEVBQThDO0FBQzVDSSxJQUFBQSxPQUFPLENBQUNDLEtBQVIseUVBQWdGTCxLQUFoRjtBQUNBTSxJQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSxDQUFiO0FBQ0Q7O0FBQ0QsU0FBT1AsS0FBUDtBQUNEOztBQUVELFNBQVNTLFVBQVQsQ0FBb0JULEtBQXBCLEVBQW1DO0FBQ2pDLE1BQUlBLEtBQUssSUFBSSxDQUFDVSxlQUFHQyxVQUFILENBQWNYLEtBQWQsQ0FBZCxFQUFvQztBQUNsQ0ksSUFBQUEsT0FBTyxDQUFDQyxLQUFSLDBFQUFnRkwsS0FBaEY7QUFDQU0sSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsQ0FBYjtBQUNEOztBQUNELFNBQU9QLEtBQVA7QUFDRDs7QUFFRCxTQUFTWSxXQUFULENBQXFCWixLQUFyQixFQUFvQztBQUNsQyxNQUFJQSxLQUFLLElBQUksQ0FBQ1UsZUFBR0MsVUFBSCxDQUFjWCxLQUFkLENBQWQsRUFBb0M7QUFDbENJLElBQUFBLE9BQU8sQ0FBQ0MsS0FBUiwyRUFBaUZMLEtBQWpGO0FBQ0FNLElBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLENBQWI7QUFDRDs7QUFDRCxTQUFPUCxLQUFQO0FBQ0Q7O0FBRUQsSUFBTWEsR0FBRyxHQUFHLElBQUlDLGtCQUFKLEdBQ1RDLE9BRFMsQ0FDREMsb0JBQUlELE9BREgsRUFFVEUsY0FGUyxDQUVNLHFCQUZOLEVBRTZCLDJCQUY3QixFQUUwRGxCLFVBRjFELEVBR1RrQixjQUhTLENBR00scUJBSE4sRUFHNkIscURBSDdCLEVBR29GVCxXQUhwRixFQUlUVSxNQUpTLENBSUYsb0JBSkUsRUFJb0IsNkJBSnBCLEVBSW1EVCxVQUpuRCxFQUtUUyxNQUxTLENBS0YscUJBTEUsRUFLcUIsK0JBTHJCLEVBS3NETixXQUx0RCxFQU1UTyxLQU5TLENBTUhiLE9BQU8sQ0FBQ2MsSUFOTCxDQUFaO0FBUU8sSUFBTUMsT0FBTyxHQUFHUixHQUFHLENBQUNTLElBQUosRUFBaEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAnY29tbWFuZGVyJztcclxuaW1wb3J0IHBrZyBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VTaGlmdCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xyXG4gICAgY29uc29sZS5lcnJvcihgJ3NoaWZ0JyBhcmd1bWVudCB2YWx1ZSBtdXN0IGFuIGludGVnZXIsIHJlY2VpdmVkOiAke3ZhbHVlfWApO1xyXG4gICAgcHJvY2Vzcy5leGl0KDEpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUFjdGlvbih2YWx1ZTogc3RyaW5nKSB7XHJcbiAgaWYgKHZhbHVlICE9PSAnZW5jb2RlJyAmJiB2YWx1ZSAhPT0gJ2RlY29kZScpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYCdhY3Rpb24nIGFyZ3VtZW50IHZhbHVlIG11c3QgYmUgJ2VuY29kZScgXFwgJ2RlY29kZScsIHJlY2VpdmVkOiAke3ZhbHVlfWApO1xyXG4gICAgcHJvY2Vzcy5leGl0KDEpO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlSW5wdXQodmFsdWU6IHN0cmluZykge1xyXG4gIGlmICh2YWx1ZSAmJiAhZnMuZXhpc3RzU3luYyh2YWx1ZSkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYCdpbnB1dCcgYXJndW1lbnQgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIHBhdGggdG8gZmlsZSwgcmVjZWl2ZWQ6ICR7dmFsdWV9YCk7XHJcbiAgICBwcm9jZXNzLmV4aXQoMSk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VPdXRwdXQodmFsdWU6IHN0cmluZykge1xyXG4gIGlmICh2YWx1ZSAmJiAhZnMuZXhpc3RzU3luYyh2YWx1ZSkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYCdvdXRwdXQnIGFyZ3VtZW50IHZhbHVlIG11c3QgYmUgYSB2YWxpZCBwYXRoIHRvIGZpbGUsIHJlY2VpdmVkOiAke3ZhbHVlfWApO1xyXG4gICAgcHJvY2Vzcy5leGl0KDEpO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbmNvbnN0IGNsaSA9IG5ldyBDb21tYW5kKClcclxuICAudmVyc2lvbihwa2cudmVyc2lvbilcclxuICAucmVxdWlyZWRPcHRpb24oJy1zLCAtLXNoaWZ0IDx2YWx1ZT4nLCAnYSBzaGlmdCwgbnVtYmVyLCByZXF1aXJlZCcsIHBhcnNlU2hpZnQpXHJcbiAgLnJlcXVpcmVkT3B0aW9uKCctYSwgLS1hY3Rpb24gPHR5cGU+JywgJ2FuIGFjdGlvbiwgcG9zc2libGUgdmFsdWVzOiBlbmNvZGUvZGVjb2RlLCByZXF1aXJlZCcsIHBhcnNlQWN0aW9uKVxyXG4gIC5vcHRpb24oJy1pLCAtLWlucHV0IDxwYXRoPicsICdwYXRoIHRvIGlucHV0IGZpbGUsIG9wdGlvbnMnLCBwYXJzZUlucHV0KVxyXG4gIC5vcHRpb24oJy1vLCAtLW91dHB1dCA8cGF0aD4nLCAncGF0aCB0byBvdXRwdXQgZmlsZSwgb3B0aW9uYWwnLCBwYXJzZU91dHB1dClcclxuICAucGFyc2UocHJvY2Vzcy5hcmd2KTtcclxuXHJcbmV4cG9ydCBjb25zdCBvcHRpb25zID0gY2xpLm9wdHMoKTtcclxuIl19